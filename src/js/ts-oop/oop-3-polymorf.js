import { person, employee, UlbiTv } from './oop-2-extends';
// ООП построено на 3 основных концепциях: Инкапсуляция, Наследование и Полиморфизм
// 3. Полиморфизм
// Полиморфизм (многообразный: poly - много, morf - форма) - принцип, который позволяет одному и тому же фрагменту кода работать с разными типами данных
// Выделяют 2 основных типа полиморфизма: Параметрический (истинный) и Ad-hoc (мнимый)
// Это один из самых важных принципов ООП, на котором основано подавляющее большинство паттернов проектирования
// Но все принципы ООП связаны между собой, так, например, полиморфизм не был бы возможен без наследования
// 3.1. Ad-hoc Полиморфизм (мнимый)
// Ad-hoc работает за счет перегрузки методов - несколько методов с одним и тем же названием, но работают с разными типами данных
// Получается так, что по сути 1 метод работает с несколькими типами данных
// В TypeScript такой тип полиморфизма отсутствует, тк невозможно переопределение методов за счет перегрузки
// Также еще одной разновидностью ad-hoc полиморфизма является `приведение типов`, например, когда мы явно какой-то дочерний класс преобразовываем к родительскому
// класс Калькулятор
class Calculator {
    add(a, b) {
        return a + b;
    }
}
const calculator = new Calculator();
calculator.add(5, 5); // 10
//calculator.add('5', '5'); // '55'
// 3.1. Параметрический Полиморфизм (истинный)
// Пример: в одной комнате встретились человек, работник и програмист. Задача их познакомить. Каждый из этих объектов должен сказать свои приветственный слова и объяснить, кто он.
// Person: Привет я человек Вася
// Employee: Привет я работник Петя
// Developer: Привет я прогер Евпатий
// Задача: реализовать такую функцию, которая сможет принимать в себя неограниченное количество объектов, унаследованных от Person (сам объект Person или любой дочерний объект)
// Первая идея, которая может прийти в голову - принимать в качестве аргументов фунции массив каждого типа (Person, Employee, Developer), а после проитерироваться по каждому из массивов и вызвать у объетов метод, отвечающий за приветствие
// Однако данный подход неэффктивен, тк у нас может быть 15, 20, 100 и более типов и использовать каждый в качестве аргумента функции нецелесообразно
// Для решения такого рода задач и был придуман полиморфизм
//UlbiTv.greeting();
//employee.greeting();
//person.greeting();
// создаем массив объектов и в качестве типа указываем базовый родительский класс
const personList = [UlbiTv, employee, person];
// функция массового приветсвия - вызываем метод greeting() у всех объектов типа Person, в тч и у дочерних объектов (Employee, Developer)
// суть полиморфизма - много форм (разные объекты), но работаем с ними по сути одинаково (вызов одного метода greeting)
// у всех объектов один и тот же метод greeting, но в каждом классе реализована своя логика
function massGreeting(persons) {
    persons.forEach(person => person.greeting());
    //for (let i = 0; i < persons.length; i++) {
    //	const person = persons[i];
    //	person.greeting();
    //}
}
massGreeting(personList);
//# sourceMappingURL=oop-3-polymorf.js.map