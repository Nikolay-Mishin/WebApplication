const f = (x) => x + 1;
const g = (x) => x * 2;
const compose = (f1, f2) => (x) => f1(f2(x));
// Мы можем применить эту функцию создания новой функции:
const h = compose(g, f);
h(10); // Возвращает 22
// Теперь представьте, что в языке есть оператор (.) для записи compose:
//const h = g.f;
// Поскольку этот оператор определён на множестве функций и он правоассоциативен, допустимо использовать несколько функций:
//const m = h.g.f;
// Это эквивалентно следующему коду:
//const m = h.(g.f);
// Или следующему, если переписать с использованием функции compose:
const m = compose(h, compose(g, f));
const pipe = (x, f) => f(x);
pipe(10, f); // Возвращает 11
// Теперь представьте, что в языке есть оператор (|>) для записи pipe:
//const result = 10 |> f;
// Поскольку этот оператор левоассоциативен, допустимо использовать его с несколькими значениями:
//const result = 10 |> f |> g;
// Это эквивалентно следующему коду:
//const result = (10 |> f) |> g;
// Или следующему, если переписать с использованием функции pipe:
const result = pipe(pipe(10, f), g); // Возвращает 22
//# sourceMappingURL=compose.js.map